---
layout: post
title: Greedy Algos and Sorting
categories: algorithms
---

# Greedy Algorithm

- Chooses what's best _right now_ and doesn't look into the future
- Suitable for **optimization problems**
- Our solution to the **coin problem** was greedy

# Sorting

- **Adjacent sort** - always $\Omega(n^2)$ and can never be $o(n^2)$ (ex. the stable insertion sort)

## Inversions

- An out-of-order pair
- Max of $\frac{n(n-1)}{2}$ inversions
- Every swap **fixes only one inversion**

## Insertion Sort

- Insertion sort is an optimal solution for adjacent elements, because it runs in $O(n^2)$

# Quicksort

Worst case $O(n^2)$, best is $O(n\ \text{log}(n))$

**Partition recursively on sublists**

## Partition

- Relies on a pivot, begin, and end pointer
- $\Theta(n)$

![Partition](https://i.imgur.com/se31YTA.png)
![P2](https://i.imgur.com/pCfU5l0.png)

## Worst case

![Worst case](https://i.imgur.com/NEsOD9s.png)

## Picking the Pivot

- Ideally, split list between left and right (the median)

### Quickselect - $\Theta(n)$ median selection

- Finds $i$th smallest element
- 1st order is min
- $n$th order is max
- $\frac{n}{2}$ is median
- Worst case $O(n^2)$
- Best is $O(n)$

#### Steps

- Partition
- If $i$ is less than the index of the partition, go left
- Otherwise, go right

![Quickselect](https://i.imgur.com/FvJahqe.png)
