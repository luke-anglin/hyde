I"3<h1 id="conversion">Conversion</h1>

<h2 id="integers---radix-to-decimal">Integers - Radix to Decimal</h2>

\[\sum_{i=0}^{n} d_i\ \times R^i\]

<h2 id="decimal-to-radix-example">Decimal to Radix Example</h2>

<p>Use the <strong>remainder</strong> method specified <a href="https://www.youtube.com/watch?v=gvJYNAiwOhc">here</a></p>

<h1 id="in-c">In C++</h1>

<ul>
  <li>Any number that <strong>begins with 0</strong> is octal</li>
  <li>Any that <strong>begins with 0x</strong> is hex</li>
</ul>

<h1 id="conversion-1">Conversion</h1>

<h2 id="binary-to-hex">Binary to Hex</h2>

<ol>
  <li>Split the binary number into 4 bit nibbles</li>
  <li>Convert each to a <strong>single</strong> hex digit</li>
</ol>

<p>1000 1101 is equivalent to 8d</p>

<h1 id="endian">Endian</h1>

<p>Byte reversal or lack thereof</p>

<ul>
  <li>Big-endian - most significant <strong>first</strong>, <strong>lowest</strong> address
    <ul>
      <li>$1000 = 2^4$</li>
      <li>0xdeadbeef</li>
    </ul>
  </li>
  <li>Little-endian - most significant <strong>last</strong>, <strong>highest</strong> address
    <ul>
      <li>$1000 = 2^0$</li>
      <li>0xefbeadde</li>
    </ul>
  </li>
</ul>

<h1 id="integers">Integers</h1>

<p>Commonly encoded by the <strong>two’s complement</strong>, which flips the bits of negative numbers and then adds one.</p>

<h2 id="twos-complement">Two’s Complement</h2>

<ul>
  <li>Zero is $n$ zeroes</li>
  <li>Encode positives in $n-1$ bits
    <ul>
      <li>Max val is $2^{n-1}-1$</li>
      <li>Sign bit is zero</li>
      <li>This zero is <strong>positive</strong> (all zeroes)</li>
    </ul>
  </li>
  <li>Negatives, encode abs val
    <ul>
      <li>Subtract that from $2^n$</li>
      <li>Max value is $-2^{n-1}$</li>
      <li><strong>OR</strong> encode abs val, flip bits, and add 1. The <span class="red">Luke method</span></li>
    </ul>
  </li>
</ul>

<h1 id="floating-point">Floating Point</h1>

<h2 id="four-parts">Four Parts</h2>

<ul>
  <li>Sign bit</li>
  <li>Mantissa - the value, in range $1.0 \leq m &lt; 10.0$ for sci notation, or $1.0 \leq m &lt; 2.0$
    <ul>
      <li>Example - $106$ is the same as $1.06 * 10^2$</li>
    </ul>
  </li>
  <li>Base</li>
  <li>Exponent - $2^(n exp -1)-1$</li>
</ul>

<h2 id="conversion-2">Conversion</h2>

<p>Once you follow these steps, it’s viable to convert to binary.</p>

<ul>
  <li>Get the mantissa between 1 and 2</li>
  <li>Make the base 2</li>
</ul>

<h2 id="ieee-bit-splitting-floats">IEEE Bit Splitting (Floats)</h2>

<p>32 bits split into</p>

<ul>
  <li>Bit 1 - Sign bit</li>
  <li>Bits 2-9 - Exponent (8 bits) - Powers of $\frac{1}{2}$</li>
  <li>Bits 10-32 - Mantissa (23 bits)</li>
</ul>

<h3 id="exponent-values">Exponent Values</h3>

<p>Exponents are <strong>not</strong> in two’s complement!</p>

<ul>
  <li>0 is for zeros - <strong>Reserved!</strong></li>
  <li>1-254 - exponent-127
    <ul>
      <li>The exponent offset or bias is 127 for binary, also known as $2^\text{num exponent digits - 1} -1$</li>
    </ul>
  </li>
  <li>255 is for NaN and overflow. <strong>Reserved!</strong></li>
</ul>

<h3 id="mantissa">Mantissa</h3>

<p>Each bit set represents a power of $\frac{1}{2}$</p>

<p>Mantissa $= 1+ \sum_{i=1}^{23} \frac{b_i}{2^i}$</p>

<p>For floating point, must be between 1 and 2. See the paper for examples worked out from past exams.</p>

<h2 id="conversion-examples">Conversion Examples</h2>

<h3 id="binary-to-decimal">Binary to Decimal</h3>

<p>For a text overview with an <span class="red">awesome formula</span> on binary to decimal floating point, see <a href="https://www.educative.io/edpresso/how-to-convert-a-single-precision-binary-float-to-decimal">this</a>.</p>

<p>The formula is</p>

\[(-1)^{ \text{sign} } \times (1 + \text{mantissa}) \times 2^{\text{exponent} - \text{exponent offset}}\]

<h3 id="decimal-to-binary">Decimal to Binary</h3>

<p>For a video on decimal to binary, use this <a href="https://www.youtube.com/watch?v=8afbTaA-gOQ&amp;t=425s">numbers goddess</a></p>

<p><strong>Steps</strong>:</p>

<p><strong>Step one</strong> - Convert the left and right to powers of two, positive and negative respectively.</p>

<p><strong>Example: 29.5</strong></p>

<p>16 + 8 + 4 + 1 and $\frac{1}{2}$</p>

<p>Which is also known as</p>

\[1*2^4+1*2^3+1*2^2+0*2^1+1*2^0+1*2^{-1}\]

<p><strong>Or, in binary</strong></p>

<p>11101.1</p>

<p><strong>Step two</strong> - Move the decimal so the mantissa is between one and two, with the respective exponent</p>

<p>1.11011 * $2^4$</p>

<p><strong>Step three</strong> - Take that exponent, and add the exponent offset, which is $2^{\text{exp bits} - 1} - 1$. Also, encode it in binary.</p>

<p>$e = 4 + \text{offset} = 131$</p>

<p>That’s</p>

<p>1000 0011</p>

<p>in binary.</p>

<p><strong>Step four</strong> - Finalize!</p>

<p><strong>Sign</strong> <strong>exponent</strong> <strong>mantissa</strong></p>

<p>1 1000001 11011—— a whole bunch of zeroes til u finish off the number</p>

<h2 id="maxs-and-mins">Maxs and Mins</h2>

<p>255 and 0 for exponent bits are reserved, so</p>

<ul>
  <li><strong>Max positive number</strong> - Ones except for a zero in the final exponent bit position and a zero in the sign bit.</li>
  <li><strong>Min positive number</strong> - All zeroes except a one in the last exponent bit position. Basically <code class="language-plaintext highlighter-rouge">xor</code> the max, except for the sign bit</li>
</ul>

<h1 id="doubles">Doubles</h1>

<h2 id="bit-splitting">Bit Splitting</h2>

<ul>
  <li>Bit 1 is for sign</li>
  <li>Bits 2-12 are for exponent (11)</li>
  <li>Bits 13-64 are for mantissa (52)</li>
  <li>Exponent offset works out to 1023 ($2^{11-1}-1$)</li>
</ul>
:ET